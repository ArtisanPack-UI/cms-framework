<?php

namespace Tests\Security;

use ArtisanPackUI\CMSFramework\Models\User;
use ArtisanPackUI\CMSFramework\Models\Role;
use ArtisanPackUI\CMSFramework\Models\Content;
use ArtisanPackUI\CMSFramework\Models\Setting;
use ArtisanPackUI\Database\seeders\RoleSeeder;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Laravel\Sanctum\Sanctum;
use Tests\TestCase;

/**
 * XSS Vulnerability Testing Suite for CMS Framework
 * 
 * This test suite performs comprehensive XSS (Cross-Site Scripting) testing including:
 * - Reflected XSS testing scenarios
 * - Stored XSS vulnerability tests
 * - DOM-based XSS detection
 * - Content Security Policy bypass tests
 * - HTML attribute injection tests
 * - JavaScript event handler injection
 * - URL-based XSS attacks
 * - JSON-based XSS vulnerabilities
 * 
 * @package Tests\Security
 */
class XssVulnerabilityTestSuite extends TestCase
{
    use RefreshDatabase;

    protected User $admin;
    protected User $editor;
    protected Content $testContent;
    protected array $xssPayloads;

    protected function setUp(): void
    {
        parent::setUp();
        
        $this->seed(RoleSeeder::class);
        $this->setupTestData();
        $this->setupXssPayloads();
    }

    /**
     * Set up test data
     */
    protected function setupTestData(): void
    {
        $adminRole = Role::where('slug', 'admin')->first();
        $editorRole = Role::where('slug', 'editor')->first();
        
        $this->admin = User::factory()->create([
            'username' => 'admin_xss_test',
            'email' => 'admin@xsstest.com',
            'role_id' => $adminRole->id,
        ]);

        $this->editor = User::factory()->create([
            'username' => 'editor_xss_test',
            'email' => 'editor@xsstest.com',
            'role_id' => $editorRole->id,
        ]);

        $this->testContent = Content::factory()->create([
            'title' => 'Test Content for XSS',
            'content' => 'Safe content body',
            'author_id' => $this->admin->id,
            'status' => 'published',
        ]);
    }

    /**
     * Set up XSS payloads for testing
     */
    protected function setupXssPayloads(): void
    {
        $this->xssPayloads = [
            // Basic script tags
            '<script>alert("XSS")</script>',
            '<script>alert(1)</script>',
            '<script>alert(String.fromCharCode(88,83,83))</script>',
            '<script>confirm("XSS")</script>',
            '<script>prompt("XSS")</script>',

            // Event handlers
            '<img src="x" onerror="alert(1)">',
            '<img src="x" onerror="alert(\'XSS\')">',
            '<svg onload="alert(1)">',
            '<body onload="alert(1)">',
            '<div onmouseover="alert(1)">Test</div>',
            '<input onfocus="alert(1)" autofocus>',
            '<select onfocus="alert(1)" autofocus><option>test</option></select>',
            '<textarea onfocus="alert(1)" autofocus></textarea>',

            // iframe injections
            '<iframe src="javascript:alert(1)"></iframe>',
            '<iframe srcdoc="<script>alert(1)</script>"></iframe>',
            '<iframe onload="alert(1)"></iframe>',

            // JavaScript URLs
            '<a href="javascript:alert(1)">Click me</a>',
            '<form action="javascript:alert(1)"><input type="submit"></form>',

            // HTML5 specific vectors
            '<details open ontoggle="alert(1)">',
            '<audio src="x" onerror="alert(1)">',
            '<video src="x" onerror="alert(1)">',
            '<marquee onstart="alert(1)">XSS</marquee>',

            // CSS injection
            '<style>body{background:url("javascript:alert(1)")}</style>',
            '<link rel="stylesheet" href="javascript:alert(1)">',
            '<style>@import"javascript:alert(1)";</style>',

            // Data URI attacks
            '<script src="data:text/javascript,alert(1)"></script>',
            '<iframe src="data:text/html,<script>alert(1)</script>"></iframe>',
            '<object data="data:text/html,<script>alert(1)</script>"></object>',

            // Encoded payloads
            '<script>alert&#40;1&#41;</script>',
            '<script>alert&#x28;1&#x29;</script>',
            '%3Cscript%3Ealert(1)%3C/script%3E',
            '&lt;script&gt;alert(1)&lt;/script&gt;',

            // Filter bypass attempts
            '<ScRiPt>alert(1)</ScRiPt>',
            '<script>alert(1)//</script>',
            '<script>/**/alert(1)/**/</script>',
            '<script>al\u0065rt(1)</script>',
            '<script>eval(String.fromCharCode(97,108,101,114,116,40,49,41))</script>',

            // SVG vectors
            '<svg><script>alert(1)</script></svg>',
            '<svg onload="alert(1)"></svg>',
            '<svg><foreignObject><script>alert(1)</script></foreignObject></svg>',

            // Form-based attacks
            '<form><button formaction="javascript:alert(1)">XSS</button></form>',
            '<input type="image" src="x" onerror="alert(1)">',

            // Template injection
            '{{alert(1)}}',
            '${alert(1)}',
            '#{alert(1)}',

            // AngularJS specific (for frontend frameworks)
            '{{constructor.constructor("alert(1)")()}}',
            '<div ng-app ng-csp><input ng-focus="$event.view.alert(1)" autofocus></div>',

            // Context-specific payloads
            '\';alert(1);//',
            '\";alert(1);//',
            '</script><script>alert(1)</script>',
            '--><script>alert(1)</script>',
        ];
    }

    /**
     * Test stored XSS in user profile fields
     */
    public function test_stored_xss_in_user_profiles(): void
    {
        Sanctum::actingAs($this->admin);

        foreach ($this->xssPayloads as $payload) {
            // Test XSS in user creation
            $response = $this->postJson('/api/cms/users', [
                'username' => 'xss_test_' . uniqid(),
                'email' => 'xss@test.com',
                'password' => 'password123',
                'first_name' => $payload,
                'last_name' => 'Test',
                'bio' => $payload,
                'website' => 'https://example.com',
            ]);

            if ($response->status() === 201) {
                $responseContent = $response->getContent();
                
                // Verify that XSS payload is properly escaped/sanitized
                $this->assertStringNotContainsString('<script>', $responseContent, 
                    'Script tags should be escaped in API responses');
                $this->assertStringNotContainsString('javascript:', $responseContent, 
                    'JavaScript URLs should be sanitized');
                $this->assertStringNotContainsString('onerror=', $responseContent, 
                    'Event handlers should be removed/escaped');
                
                // Check for proper HTML entity encoding
                if (strpos($payload, '<') !== false) {
                    $this->assertStringContainsString('&lt;', $responseContent, 
                        'HTML entities should be properly encoded');
                }
            } else {
                // If validation rejected the payload, that's also acceptable
                $this->assertContains($response->status(), [422], 
                    'XSS payloads should be rejected by validation or properly sanitized');
            }

            // Test XSS in user update
            $response = $this->putJson("/api/cms/users/{$this->editor->id}", [
                'first_name' => $payload,
                'bio' => 'Updated bio: ' . $payload,
            ]);

            if ($response->status() === 200) {
                $responseContent = $response->getContent();
                $this->assertStringNotContainsString('<script>', $responseContent, 
                    'Script tags should be escaped in update responses');
            }
        }
    }

    /**
     * Test stored XSS in content management
     */
    public function test_stored_xss_in_content(): void
    {
        Sanctum::actingAs($this->admin);

        foreach ($this->xssPayloads as $payload) {
            // Test XSS in content creation
            $response = $this->postJson('/api/cms/content', [
                'title' => 'XSS Test: ' . $payload,
                'content' => 'Content with XSS: ' . $payload,
                'excerpt' => 'Excerpt: ' . $payload,
                'content_type' => 'post',
                'status' => 'published',
                'slug' => 'xss-test-' . uniqid(),
                'meta_title' => 'Meta Title: ' . $payload,
                'meta_description' => 'Meta Description: ' . $payload,
                'author_id' => $this->admin->id,
            ]);

            if ($response->status() === 201) {
                $responseContent = $response->getContent();
                
                // Verify content is properly sanitized
                $this->assertStringNotContainsString('<script>', $responseContent, 
                    'Script tags should be sanitized in content');
                $this->assertStringNotContainsString('javascript:', $responseContent, 
                    'JavaScript URLs should be removed from content');
                $this->assertStringNotContainsString('onerror=', $responseContent, 
                    'Event handlers should be sanitized in content');
                
                // Get the created content and verify it's sanitized in database
                $content = Content::latest()->first();
                $this->assertStringNotContainsString('<script>', $content->title, 
                    'Script tags should not be stored in database');
                $this->assertStringNotContainsString('<script>', $content->content, 
                    'Script tags should not be stored in content body');
            }

            // Test XSS in content update
            $response = $this->putJson("/api/cms/content/{$this->testContent->id}", [
                'title' => 'Updated Title: ' . $payload,
                'content' => 'Updated content: ' . $payload,
            ]);

            if ($response->status() === 200) {
                $responseContent = $response->getContent();
                $this->assertStringNotContainsString('<script>', $responseContent, 
                    'Script tags should be sanitized in content updates');
            }
        }
    }

    /**
     * Test reflected XSS in search and filter parameters
     */
    public function test_reflected_xss_in_search(): void
    {
        Sanctum::actingAs($this->admin);

        foreach ($this->xssPayloads as $payload) {
            // Test XSS in user search
            $response = $this->getJson('/api/cms/users?search=' . urlencode($payload));

            $responseContent = $response->getContent();
            
            // Verify that search parameters are not reflected without escaping
            $this->assertStringNotContainsString('<script>', $responseContent, 
                'Script tags should not be reflected in search results');
            $this->assertStringNotContainsString('javascript:', $responseContent, 
                'JavaScript URLs should not be reflected');
            
            // Test XSS in content search
            $response = $this->getJson('/api/cms/content?search=' . urlencode($payload));
            $responseContent = $response->getContent();
            
            $this->assertStringNotContainsString('<script>', $responseContent, 
                'Script tags should not be reflected in content search');

            // Test XSS in filter parameters
            $response = $this->getJson('/api/cms/content?status=' . urlencode($payload));
            $responseContent = $response->getContent();
            
            $this->assertStringNotContainsString('<script>', $responseContent, 
                'Script tags should not be reflected in filter responses');
        }
    }

    /**
     * Test XSS in JSON API responses
     */
    public function test_xss_in_json_responses(): void
    {
        Sanctum::actingAs($this->admin);

        $jsonXssPayloads = [
            '</script><script>alert(1)</script>',
            '{"xss": "<script>alert(1)</script>"}',
            '\u003cscript\u003ealert(1)\u003c/script\u003e',
            '\\";alert(1);//',
        ];

        foreach ($jsonXssPayloads as $payload) {
            // Test XSS in settings
            $response = $this->postJson('/api/cms/settings', [
                'key' => 'xss_test_' . uniqid(),
                'value' => $payload,
                'description' => 'XSS test setting',
            ]);

            if ($response->status() === 201) {
                $responseContent = $response->getContent();
                
                // JSON responses should properly escape XSS
                $this->assertStringNotContainsString('<script>', $responseContent, 
                    'Script tags should be escaped in JSON responses');
                
                // Verify proper JSON encoding
                $decodedResponse = json_decode($responseContent, true);
                $this->assertIsArray($decodedResponse, 
                    'Response should be valid JSON');
                
                // If the payload made it through, it should be escaped
                if (isset($decodedResponse['value'])) {
                    $this->assertStringNotContainsString('<script>', $decodedResponse['value'], 
                        'XSS should be escaped even in JSON values');
                }
            }
        }
    }

    /**
     * Test XSS in file upload scenarios
     */
    public function test_xss_in_file_uploads(): void
    {
        Sanctum::actingAs($this->admin);

        $maliciousFilenames = [
            '<script>alert(1)</script>.jpg',
            'test<svg onload=alert(1)>.png',
            '"><script>alert(1)</script>.gif',
            'test.php<script>alert(1)</script>',
        ];

        foreach ($maliciousFilenames as $filename) {
            // Create a fake file with malicious filename
            $fakeFileContent = 'fake image content';
            
            // Test media upload with malicious filename
            $response = $this->postJson('/api/cms/media', [
                'title' => 'XSS Test Upload: ' . $filename,
                'alt_text' => 'Alt text with XSS: <script>alert(1)</script>',
                'description' => 'Description with XSS: <img src=x onerror=alert(1)>',
                // Note: In a real test, you'd upload an actual file
                // This tests the metadata handling
            ]);

            if ($response->status() === 201) {
                $responseContent = $response->getContent();
                
                // Verify filename and metadata are sanitized
                $this->assertStringNotContainsString('<script>', $responseContent, 
                    'Script tags should be sanitized in file metadata');
                $this->assertStringNotContainsString('onerror=', $responseContent, 
                    'Event handlers should be removed from file metadata');
            }
        }
    }

    /**
     * Test DOM-based XSS prevention in API responses
     */
    public function test_dom_based_xss_prevention(): void
    {
        Sanctum::actingAs($this->admin);

        $domXssPayloads = [
            '#<script>alert(1)</script>',
            'javascript:alert(1)',
            'data:text/html,<script>alert(1)</script>',
            'vbscript:msgbox(1)',
            'file:///etc/passwd',
        ];

        foreach ($domXssPayloads as $payload) {
            // Test in user website field (URL field)
            $response = $this->postJson('/api/cms/users', [
                'username' => 'dom_xss_test_' . uniqid(),
                'email' => 'domxss@test.com',
                'password' => 'password123',
                'first_name' => 'DOM',
                'last_name' => 'XSS',
                'website' => $payload,
            ]);

            if ($response->status() === 201) {
                $responseContent = $response->getContent();
                
                // Verify dangerous URL schemes are rejected or sanitized
                $this->assertStringNotContainsString('javascript:', $responseContent, 
                    'JavaScript URLs should be rejected');
                $this->assertStringNotContainsString('data:', $responseContent, 
                    'Data URLs should be rejected in URL fields');
                $this->assertStringNotContainsString('vbscript:', $responseContent, 
                    'VBScript URLs should be rejected');
            } else {
                // Validation rejection is also acceptable
                $this->assertEquals(422, $response->status(), 
                    'Dangerous URLs should be rejected by validation');
            }
        }
    }

    /**
     * Test XSS in nested JSON data structures
     */
    public function test_xss_in_nested_json(): void
    {
        Sanctum::actingAs($this->admin);

        $nestedXssPayload = [
            'settings' => [
                'theme' => '<script>alert(1)</script>',
                'colors' => [
                    'primary' => '<img src=x onerror=alert(1)>',
                    'secondary' => 'javascript:alert(1)'
                ]
            ],
            'metadata' => [
                'title' => '</script><script>alert(1)</script>',
                'tags' => ['<svg onload=alert(1)>', 'normal-tag']
            ]
        ];

        // Test nested XSS in user settings
        $response = $this->postJson('/api/cms/users', array_merge([
            'username' => 'nested_xss_' . uniqid(),
            'email' => 'nestedxss@test.com',
            'password' => 'password123',
            'first_name' => 'Nested',
            'last_name' => 'XSS',
        ], $nestedXssPayload));

        if ($response->status() === 201) {
            $responseContent = $response->getContent();
            
            // Verify nested XSS is sanitized
            $this->assertStringNotContainsString('<script>', $responseContent, 
                'Nested script tags should be sanitized');
            $this->assertStringNotContainsString('onerror=', $responseContent, 
                'Nested event handlers should be removed');
            $this->assertStringNotContainsString('javascript:', $responseContent, 
                'Nested JavaScript URLs should be sanitized');
        }
    }

    /**
     * Test Content Security Policy headers (if implemented)
     */
    public function test_content_security_policy_headers(): void
    {
        Sanctum::actingAs($this->admin);

        $response = $this->getJson('/api/cms/users');

        // Check for security headers that help prevent XSS
        $headers = $response->headers->all();
        
        // While not strictly required for API endpoints, these headers can provide defense in depth
        $securityHeaders = [
            'x-content-type-options',
            'x-frame-options', 
            'x-xss-protection',
            'content-security-policy',
        ];

        foreach ($securityHeaders as $header) {
            if (isset($headers[$header])) {
                $this->assertNotEmpty($headers[$header][0], 
                    "Security header {$header} should have a value if present");
            }
        }

        // The response should have proper content type
        $this->assertEquals('application/json', $response->headers->get('content-type'), 
            'API responses should have proper content type');
    }

    /**
     * Test XSS in error messages
     */
    public function test_xss_in_error_messages(): void
    {
        $xssPayload = '<script>alert("XSS in error")</script>';

        // Test XSS in authentication error
        $response = $this->postJson('/api/cms/auth/login', [
            'email' => $xssPayload,
            'password' => 'wrongpassword',
            'device_name' => 'XSS Test'
        ]);

        $responseContent = $response->getContent();
        $this->assertStringNotContainsString('<script>', $responseContent, 
            'Script tags should not appear in authentication error messages');

        // Test XSS in validation errors
        Sanctum::actingAs($this->admin);
        
        $response = $this->postJson('/api/cms/users', [
            'username' => $xssPayload,
            'email' => 'invalid-email', // This will trigger validation error
            // Missing required fields will also trigger errors
        ]);

        $responseContent = $response->getContent();
        $this->assertStringNotContainsString('<script>', $responseContent, 
            'Script tags should not appear in validation error messages');
        
        // Error messages should be properly escaped
        if ($response->status() === 422) {
            $decodedResponse = json_decode($responseContent, true);
            if (isset($decodedResponse['errors'])) {
                foreach ($decodedResponse['errors'] as $field => $errors) {
                    foreach ($errors as $error) {
                        $this->assertStringNotContainsString('<script>', $error, 
                            'Error messages should not contain script tags');
                    }
                }
            }
        }
    }

    /**
     * Test that HTML sanitization preserves safe content
     */
    public function test_html_sanitization_preserves_safe_content(): void
    {
        Sanctum::actingAs($this->admin);

        $safeHtmlContent = [
            'title' => 'Safe HTML Test',
            'content' => '<p>This is <strong>safe</strong> HTML content with <em>emphasis</em> and <a href="https://example.com">links</a>.</p>',
            'excerpt' => 'Safe <em>excerpt</em> with formatting',
            'content_type' => 'post',
            'status' => 'published',
            'slug' => 'safe-html-test',
            'author_id' => $this->admin->id,
        ];

        $response = $this->postJson('/api/cms/content', $safeHtmlContent);

        if ($response->status() === 201) {
            $responseContent = $response->getContent();
            $decodedResponse = json_decode($responseContent, true);
            
            // Safe HTML should be preserved (or properly handled according to business rules)
            // This test verifies that sanitization doesn't break legitimate content
            $this->assertStringContainsString('Safe HTML Test', $responseContent, 
                'Safe content should be preserved');
            
            // The system should handle safe HTML tags appropriately
            // (either preserve them or convert them consistently)
            $this->assertTrue(
                strpos($responseContent, '<p>') !== false || 
                strpos($responseContent, '&lt;p&gt;') !== false,
                'Safe HTML tags should be handled consistently'
            );
        }
    }
}